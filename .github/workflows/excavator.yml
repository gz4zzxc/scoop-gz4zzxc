name: Auto Update Manifests

on:
  schedule:
    # Run at 8:00 AM Beijing Time (UTC+8) = 00:00 UTC every day
    - cron: '0 0 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  update-manifests:
    runs-on: ubuntu-latest
    concurrency:
      group: update-manifests-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4


      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install requests beautifulsoup4 lxml

      - name: Validate current manifests
        run: |
          echo "Validating manifest files..."
          for manifest in bucket/*.json; do
            echo "Checking $manifest..."
            python3 -m json.tool "$manifest" > /dev/null && echo "‚úÖ $manifest is valid JSON" || echo "‚ùå $manifest has invalid JSON"
          done

      - name: Check for AliyunDrive updates
        id: check-updates
        run: |
          python3 << 'EOF'
          import json
          import re
          import requests
          from datetime import datetime
          import os

          def check_aliyundrive_update():
              try:
                  # Read current version from manifest
                  with open('bucket/aliyundrive.json', 'r', encoding='utf-8') as f:
                      manifest = json.load(f)
                  current_version = manifest['version']

                  print(f"Current version: {current_version}")

                  # Method 1: Try to fetch download page directly
                  try:
                      response = requests.get('https://www.aliyundrive.com/download',
                                            timeout=30,
                                            headers={
                                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                                            })
                      response.raise_for_status()

                      # Extract version from download URL
                      version_match = re.search(r'aDrive-(\d+\.\d+\.\d+)\.exe', response.text)
                      if version_match:
                          latest_version = version_match.group(1)
                          print(f"Found version from download page: {latest_version}")
                      else:
                          raise Exception("Version not found in download page")

                  except Exception as e:
                      print(f"Method 1 failed: {e}")
                      # Method 2: Check if current version download URL is still valid
                      current_download_url = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-{current_version}.exe"
                      print(f"Checking if current version download URL is still valid: {current_download_url}")
                      try:
                          head_response = requests.head(current_download_url, timeout=10, headers={
                              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                          })
                          if head_response.status_code == 200:
                              print("‚úÖ Current version download URL is still valid, assuming no update")
                              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                                  f.write(f"updated=false\n")
                              return False
                          else:
                              print(f"‚ùå Current download URL returned {head_response.status_code}")
                      except Exception as url_check_error:
                          print(f"‚ùå Error checking current download URL: {url_check_error}")

                      # Method 3: Try common version increments
                      version_parts = current_version.split('.')
                      if len(version_parts) == 3:
                          # Try incrementing patch version
                          patch = int(version_parts[2])
                          for i in range(1, 10):  # Try next 9 patch versions
                              test_version = f"{version_parts[0]}.{version_parts[1]}.{patch + i}"
                              test_url = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-{test_version}.exe"
                              print(f"Testing version {test_version}...")
                              test_response = requests.head(test_url, timeout=5, headers={
                                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                              })
                              if test_response.status_code == 200:
                                  latest_version = test_version
                                  print(f"Found newer version: {latest_version}")
                                  break
                          else:
                              print("No newer version found through URL testing")
                              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                                  f.write(f"updated=false\n")
                              return False
                      else:
                          print("Cannot parse current version format")
                          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                              f.write(f"updated=false\n")
                          return False

                  download_url = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-{latest_version}.exe"
                  print(f"Latest version: {latest_version}")

                  if latest_version != current_version:
                      # Verify the new URL exists with proper User-Agent
                      verify_response = requests.head(download_url, timeout=10, headers={
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                      })
                      if verify_response.status_code != 200:
                          print(f"‚ùå New version URL not accessible: {verify_response.status_code}")
                          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                              f.write(f"updated=false\n")
                          return False

                      # Update manifest - keep the placeholder URL structure but update version
                      manifest['version'] = latest_version
                      # Keep the placeholder URL structure unchanged - it uses placeholder.txt
                      # The pre_install script already uses $version variable, so it will automatically use the new version

                      # Update autoupdate URL
                      if 'autoupdate' in manifest:
                          manifest['autoupdate']['url'] = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-$version.exe"

                      # Write updated manifest
                      with open('bucket/aliyundrive.json', 'w', encoding='utf-8') as f:
                          json.dump(manifest, f, indent=4, ensure_ascii=False)

                      # Set output for GitHub Actions
                      with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                          f.write(f"updated=true\n")
                          f.write(f"old_version={current_version}\n")
                          f.write(f"new_version={latest_version}\n")

                      print(f"‚úÖ Updated AliyunDrive from {current_version} to {latest_version}")
                      return True
                  else:
                      print("‚úÖ AliyunDrive is up to date")
                      with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                          f.write(f"updated=false\n")
                      return False

              except Exception as e:
                  print(f"‚ùå Error checking AliyunDrive updates: {e}")
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"updated=false\n")
                  return False

          check_aliyundrive_update()
          EOF

      - name: Update README if version changed
        if: steps.check-updates.outputs.updated == 'true'
        run: |
          python3 << 'EOF'
          import re

          # Read README
          with open('README.md', 'r', encoding='utf-8') as f:
              content = f.read()

          # Update version in table
          old_version = "${{ steps.check-updates.outputs.old_version }}"
          new_version = "${{ steps.check-updates.outputs.new_version }}"

          # Replace version in the table
          pattern = r'(\| aliyundrive \| .+ \| )' + re.escape(old_version) + r'( \|)'
          replacement = r'\g<1>' + new_version + r'\g<2>'
          content = re.sub(pattern, replacement, content)

          # Write updated README
          with open('README.md', 'w', encoding='utf-8') as f:
              f.write(content)

          print(f"‚úÖ Updated README version from {old_version} to {new_version}")
          EOF

      - name: Create Pull Request for AliyunDrive update
        if: steps.check-updates.outputs.updated == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          branch: auto/aliyundrive-${{ steps.check-updates.outputs.new_version }}
          commit-message: |
            chore(aliyundrive): bump to v${{ steps.check-updates.outputs.new_version }}

            - Updated from v${{ steps.check-updates.outputs.old_version }} to v${{ steps.check-updates.outputs.new_version }}
            - Auto-detected from https://www.aliyundrive.com/download
            - Run: ${{ github.run_id }}
          title: "ü§ñ Auto-update: AliyunDrive v${{ steps.check-updates.outputs.new_version }}"
          body: |
            This PR updates AliyunDrive from v${{ steps.check-updates.outputs.old_version }} to v${{ steps.check-updates.outputs.new_version }}.

            - Download: https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-${{ steps.check-updates.outputs.new_version }}.exe
            - Updated by workflow run: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          labels: auto-update, aliyundrive
          add-paths: |
            bucket/aliyundrive.json
            README.md

      # Align with official buckets: do not create issues/releases for auto updates

      # Removed release creation step

  # Êñ∞Â¢ûÔºö‰ΩøÁî®ÂÆòÊñπ Excavator Ëá™Âä®Êõ¥Êñ∞ÂÖ∂‰ªñÂ∫îÁî®
  update-other-apps:
    runs-on: windows-latest
    needs: update-manifests
    concurrency:
      group: update-other-apps-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Custom update trafficmonitor
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $repo = 'zhongyang219/TrafficMonitor'
          $api = "https://api.github.com/repos/$repo/releases/latest"
          $headers = @{ 'User-Agent' = 'gh-actions'; 'Accept' = 'application/vnd.github+json' }
          $resp = Invoke-RestMethod -Uri $api -Headers $headers -UseBasicParsing
          if (-not $resp.tag_name) { throw 'Failed to fetch latest release' }
          $tag = [string]$resp.tag_name  # e.g. V1.85.1
          $version = $tag.TrimStart('V','v')

          Write-Host "Latest tag: $tag; version: $version"

          $assets = @{}
          foreach ($asset in $resp.assets) {
            $assets[$asset.name] = $asset.browser_download_url
          }

          $map = @{
            'x64'   = "TrafficMonitor_V$version`_x64.zip"
            'x86'   = "TrafficMonitor_V$version`_x86.zip"
            'arm64' = "TrafficMonitor_V$version`_arm64ec.zip"
          }

          $tmp = New-Item -ItemType Directory -Path (Join-Path $env:TEMP "tm_$version") -Force
          $hashes = @{}
          foreach ($arch in $map.Keys) {
            $name = $map[$arch]
            if (-not $assets.ContainsKey($name)) { throw "Missing asset $name in latest release" }
            $url = $assets[$name]
            $out = Join-Path $tmp.FullName $name
            Write-Host "Downloading $name ..."
            Invoke-WebRequest -UseBasicParsing -Uri $url -OutFile $out
            $sha = (Get-FileHash -Algorithm SHA256 $out).Hash.ToUpper()
            $hashes[$arch] = @{ url = $url; sha = $sha }
          }

          $manifestPath = 'bucket/trafficmonitor.json'
          $json = Get-Content $manifestPath -Raw | ConvertFrom-Json
          $json.version = $version
          $json.architecture.'64bit'.url  = $hashes['x64'].url
          $json.architecture.'64bit'.hash = $hashes['x64'].sha
          $json.architecture.'32bit'.url  = $hashes['x86'].url
          $json.architecture.'32bit'.hash = $hashes['x86'].sha
          $json.architecture.arm64.url    = $hashes['arm64'].url
          $json.architecture.arm64.hash   = $hashes['arm64'].sha

          # Prepare new JSON content and write only when content actually changes
          $original = Get-Content $manifestPath -Raw
          $newContent = ($json | ConvertTo-Json -Depth 32)
          if ($newContent -ne $original) {
            $newContent | Set-Content -Path $manifestPath -Encoding utf8NoBOM
            Write-Host "Updated $manifestPath to $version"
          } else {
            Write-Host "No real changes in $manifestPath; skip writing"
          }

      - name: Check for changes
        id: check-changes
        shell: pwsh
        run: |
          if (git diff --quiet) {
            "no-changes=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "‚úÖ No changes detected"
          } else {
            "no-changes=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "üìù Changes detected"
            git diff --name-only
          }

      - name: Create Pull Request for Traffic Monitor update
        if: steps.check-changes.outputs.no-changes == 'false'
        uses: peter-evans/create-pull-request@v6
        with:
          branch: auto/trafficmonitor-${{ steps.check-changes.id }}-${{ github.run_id }}
          commit-message: |
            chore(trafficmonitor): auto-update manifest to latest GitHub release
          title: "ü§ñ Auto-update: Traffic Monitor"
          body: |
            This PR updates Traffic Monitor manifest to the latest GitHub release detected on the Windows runner.

            Workflow Run: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          labels: auto-update, trafficmonitor
          add-paths: |
            bucket/trafficmonitor.json

      # Removed issue creation for Traffic Monitor
