name: Auto Update Manifests

on:
  schedule:
    # Run at 8:00 AM Beijing Time (UTC+8) = 00:00 UTC every day
    - cron: '0 0 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  update-manifests:
    runs-on: ubuntu-latest
    concurrency:
      group: update-manifests-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4


      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install requests beautifulsoup4 lxml

      - name: Validate current manifests
        run: |
          echo "Validating manifest files..."
          for manifest in bucket/*.json; do
            echo "Checking $manifest..."
            python3 -m json.tool "$manifest" > /dev/null && echo "‚úÖ $manifest is valid JSON" || echo "‚ùå $manifest has invalid JSON"
          done

      - name: Check for AliyunDrive updates
        id: check-updates
        run: |
          python3 << 'EOF'
          import json
          import re
          import requests
          from datetime import datetime
          import os

          def check_aliyundrive_update():
              try:
                  # Read current version from manifest
                  with open('bucket/aliyundrive.json', 'r', encoding='utf-8') as f:
                      manifest = json.load(f)
                  current_version = manifest['version']

                  print(f"Current version: {current_version}")

                  # Method 1: Try to fetch download page directly
                  try:
                      response = requests.get('https://www.aliyundrive.com/download',
                                            timeout=30,
                                            headers={
                                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                                            })
                      response.raise_for_status()

                      # Extract version from download URL
                      version_match = re.search(r'aDrive-(\d+\.\d+\.\d+)\.exe', response.text)
                      if version_match:
                          latest_version = version_match.group(1)
                          print(f"Found version from download page: {latest_version}")
                      else:
                          raise Exception("Version not found in download page")

                  except Exception as e:
                      print(f"Method 1 failed: {e}")
                      # Method 2: Check if current version download URL is still valid
                      current_download_url = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-{current_version}.exe"
                      print(f"Checking if current version download URL is still valid: {current_download_url}")
                      try:
                          head_response = requests.head(current_download_url, timeout=10, headers={
                              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                          })
                          if head_response.status_code == 200:
                              print("‚úÖ Current version download URL is still valid, assuming no update")
                              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                                  f.write(f"updated=false\n")
                              return False
                          else:
                              print(f"‚ùå Current download URL returned {head_response.status_code}")
                      except Exception as url_check_error:
                          print(f"‚ùå Error checking current download URL: {url_check_error}")

                      # Method 3: Try common version increments
                      version_parts = current_version.split('.')
                      if len(version_parts) == 3:
                          # Try incrementing patch version
                          patch = int(version_parts[2])
                          for i in range(1, 10):  # Try next 9 patch versions
                              test_version = f"{version_parts[0]}.{version_parts[1]}.{patch + i}"
                              test_url = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-{test_version}.exe"
                              print(f"Testing version {test_version}...")
                              test_response = requests.head(test_url, timeout=5, headers={
                                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                              })
                              if test_response.status_code == 200:
                                  latest_version = test_version
                                  print(f"Found newer version: {latest_version}")
                                  break
                          else:
                              print("No newer version found through URL testing")
                              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                                  f.write(f"updated=false\n")
                              return False
                      else:
                          print("Cannot parse current version format")
                          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                              f.write(f"updated=false\n")
                          return False

                  download_url = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-{latest_version}.exe"
                  print(f"Latest version: {latest_version}")

                  if latest_version != current_version:
                      # Verify the new URL exists with proper User-Agent
                      verify_response = requests.head(download_url, timeout=10, headers={
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                      })
                      if verify_response.status_code != 200:
                          print(f"‚ùå New version URL not accessible: {verify_response.status_code}")
                          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                              f.write(f"updated=false\n")
                          return False

                      # Update manifest - keep the placeholder URL structure but update version
                      manifest['version'] = latest_version
                      # Keep the placeholder URL structure unchanged - it uses placeholder.txt
                      # The pre_install script already uses $version variable, so it will automatically use the new version

                      # Update autoupdate URL
                      if 'autoupdate' in manifest:
                          manifest['autoupdate']['url'] = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-$version.exe"

                      # Write updated manifest
                      with open('bucket/aliyundrive.json', 'w', encoding='utf-8') as f:
                          json.dump(manifest, f, indent=4, ensure_ascii=False)

                      # Set output for GitHub Actions
                      with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                          f.write(f"updated=true\n")
                          f.write(f"old_version={current_version}\n")
                          f.write(f"new_version={latest_version}\n")

                      print(f"‚úÖ Updated AliyunDrive from {current_version} to {latest_version}")
                      return True
                  else:
                      print("‚úÖ AliyunDrive is up to date")
                      with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                          f.write(f"updated=false\n")
                      return False

              except Exception as e:
                  print(f"‚ùå Error checking AliyunDrive updates: {e}")
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"updated=false\n")
                  return False

          check_aliyundrive_update()
          EOF

      - name: Check for Miniforge updates
        id: check-miniforge
        run: |
          python3 << 'EOF'
          import json
          import re
          import os
          import requests

          def latest_miniforge():
              api = 'https://api.github.com/repos/conda-forge/miniforge/releases/latest'
              r = requests.get(api, timeout=30, headers={'Accept':'application/vnd.github+json','User-Agent':'gh-actions'})
              r.raise_for_status()
              data = r.json()
              tag = data.get('tag_name')
              assets = data.get('assets', [])
              exe_name = f'Miniforge3-{tag}-Windows-x86_64.exe'
              sha_name = exe_name + '.sha256'
              exe_url = None
              sha_url = None
              for a in assets:
                  if a.get('name') == exe_name:
                      exe_url = a.get('browser_download_url')
                  if a.get('name') == sha_name:
                      sha_url = a.get('browser_download_url')
              if not exe_url or not sha_url:
                  raise RuntimeError('Miniforge Windows x86_64 asset or sha256 not found')
              sha_resp = requests.get(sha_url, timeout=30)
              sha_resp.raise_for_status()
              m = re.search(r'^([0-9a-fA-F]{64})', sha_resp.text)
              if not m:
                  raise RuntimeError('Unable to parse sha256')
              sha = m.group(1).lower()
              return tag, exe_url, sha

          try:
              manifest_path = 'bucket/miniforge.json'
              with open(manifest_path, 'r', encoding='utf-8') as f:
                  manifest = json.load(f)
              current_version = manifest.get('version')

              new_version, exe_url, sha = latest_miniforge()

              desired_url = f'https://github.com/conda-forge/miniforge/releases/download/{new_version}/Miniforge3-{new_version}-Windows-x86_64.exe'
              updated = False

              if manifest.get('version') != new_version:
                  updated = True
                  manifest['version'] = new_version

              arch = manifest.setdefault('architecture', {})
              arch64 = arch.setdefault('64bit', {})
              if arch64.get('url') != desired_url:
                  updated = True
                  arch64['url'] = desired_url
              if arch64.get('hash', '').lower() != sha.lower():
                  updated = True
                  arch64['hash'] = sha
              if 'arm64' in arch:
                  updated = True
                  arch.pop('arm64', None)

              desired_autoupdate = {
                  'architecture': {
                      '64bit': {
                          'url': 'https://github.com/conda-forge/miniforge/releases/download/$version/Miniforge3-$version-Windows-x86_64.exe'
                      }
                  },
                  'hash': {
                      'url': 'https://github.com/conda-forge/miniforge/releases/download/$version/Miniforge3-$version-Windows-x86_64.exe.sha256',
                      'regex': '^([a-fA-F]{64})'
                  }
              }
              if manifest.get('autoupdate') != desired_autoupdate:
                  manifest['autoupdate'] = desired_autoupdate
                  updated = True

              if updated:
                  with open(manifest_path, 'w', encoding='utf-8') as f:
                      json.dump(manifest, f, indent=2, ensure_ascii=False)
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write('updated=true\n')
                      f.write(f'old_version={current_version}\n')
                      f.write(f'new_version={new_version}\n')
                  print(f'Updated Miniforge from {current_version} to {new_version}')
              else:
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write('updated=false\n')
                  print('Miniforge is up to date')
          except Exception as e:
              print(f'Error checking Miniforge: {e}')
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write('updated=false\n')
          EOF

    - name: Check for LobeChat updates
    id: check-lobechat
    run: |
      python3 <<'EOF'
      import json, os, re, requests, hashlib

      MANIFEST = 'bucket/lobechat.json'
      REPO = 'lobehub/lobe-chat'
      api = f'https://api.github.com/repos/{REPO}/releases/latest'
      headers = {'Accept':'application/vnd.github+json','User-Agent':'gh-actions'}
      try:
        if os.path.exists(MANIFEST):
          with open(MANIFEST,'r',encoding='utf-8') as f:
            manifest = json.load(f)
        else:
          manifest = {
            'version':'0.0.0',
            'description':'LobeChat desktop client',
            'homepage':'https://github.com/lobehub/lobe-chat',
            'license':'Apache-2.0'
          }
        current_version = manifest.get('version','0.0.0')
        resp = requests.get(api, timeout=30, headers=headers)
        resp.raise_for_status()
        data = resp.json()
        tag = data.get('tag_name','')
        if not tag:
          raise RuntimeError('No tag_name in latest release response')
        version = tag.lstrip('vV')
        pattern = re.compile(rf'^LobeHub-Beta-{re.escape(version)}-setup\\.exe$')
        asset = next((a for a in data.get('assets', []) if pattern.match(a.get('name',''))), None)
        if not asset:
          raise RuntimeError('Setup asset not found')
        url = asset.get('browser_download_url')
        if not url:
          raise RuntimeError('Asset missing download url')
        dl = requests.get(url, timeout=600, stream=True, headers=headers)
        dl.raise_for_status()
        h = hashlib.sha256(); size=0
        for chunk in dl.iter_content(262144):
          if not chunk: continue
          h.update(chunk); size += len(chunk)
        sha256 = h.hexdigest()
        updated = False
        if manifest.get('version') != version:
          manifest['version'] = version; updated = True
        desired_url = f"https://github.com/lobehub/lobe-chat/releases/download/v{version}/LobeHub-Beta-{version}-setup.exe#dl.7z"
        if manifest.get('url') != desired_url:
          manifest['url'] = desired_url; updated = True
        if manifest.get('hash','').lower() != sha256.lower():
          manifest['hash'] = sha256; updated = True
        if manifest.get('checkver') != {'github':'lobehub/lobe-chat','regex':'v([\\d.]+)'}:
          manifest['checkver'] = {'github':'lobehub/lobe-chat','regex':'v([\\d.]+)'}; updated = True
        if manifest.get('autoupdate') != {'url':'https://github.com/lobehub/lobe-chat/releases/download/v$version/LobeHub-Beta-$version-setup.exe#dl.7z'}:
          manifest['autoupdate'] = {'url':'https://github.com/lobehub/lobe-chat/releases/download/v$version/LobeHub-Beta-$version-setup.exe#dl.7z'}; updated = True
        if updated:
          with open(MANIFEST,'w',encoding='utf-8') as f: json.dump(manifest,f,indent=2,ensure_ascii=False)
          with open(os.environ['GITHUB_OUTPUT'],'a') as f:
            f.write('updated=true\n'); f.write(f'old_version={current_version}\n'); f.write(f'new_version={version}\n')
          print(f'Updated LobeChat {current_version} -> {version} (~{size/1024/1024:.2f} MB)')
        else:
          with open(os.environ['GITHUB_OUTPUT'],'a') as f: f.write('updated=false\n')
          print('LobeChat is up to date')
      except Exception as e:
        print('Error updating LobeChat:', e)
        with open(os.environ['GITHUB_OUTPUT'],'a') as f: f.write('updated=false\n')
      EOF

      - name: Update README if version changed
        if: steps.check-updates.outputs.updated == 'true' || steps.check-miniforge.outputs.updated == 'true' || steps.check-lobechat.outputs.updated == 'true'
        run: |
          python3 << 'EOF'
          import re

          with open('README.md', 'r', encoding='utf-8') as f:
              content = f.read()

          old_ad = "${{ steps.check-updates.outputs.old_version }}" or None
          new_ad = "${{ steps.check-updates.outputs.new_version }}" or None
          if old_ad and new_ad:
              pattern = r'(\| aliyundrive \| .+ \| )' + re.escape(old_ad) + r'( \|)'
              replacement = r'\g<1>' + new_ad + r'\g<2>'
              content = re.sub(pattern, replacement, content)

          old_mf = "${{ steps.check-miniforge.outputs.old_version }}" or None
          new_mf = "${{ steps.check-miniforge.outputs.new_version }}" or None
          if old_mf and new_mf:
              pattern = r'(\| miniforge \| .+ \| )' + re.escape(old_mf) + r'( \|)'
              replacement = r'\g<1>' + new_mf + r'\g<2>'
              content = re.sub(pattern, replacement, content)

          old_lc = "${{ steps.check-lobechat.outputs.old_version }}" or None
          new_lc = "${{ steps.check-lobechat.outputs.new_version }}" or None
          if old_lc and new_lc:
              pattern = r'(\| lobechat \| .+ \| )' + re.escape(old_lc) + r'( \|)'
              replacement = r'\g<1>' + new_lc + r'\g<2>'
              content = re.sub(pattern, replacement, content)

          with open('README.md', 'w', encoding='utf-8') as f:
              f.write(content)
          EOF

      - name: Check for manifest changes
        id: check-changes-manifests
        run: |
          if git diff --quiet; then
            echo "no-changes=true" >> $GITHUB_OUTPUT
            echo "No changes detected"
          else:
            echo "no-changes=false" >> $GITHUB_OUTPUT
            git diff --name-only
          fi

      - name: Create Pull Request for manifest updates
        if: steps.check-changes-manifests.outputs.no-changes == 'false'
        id: cpr_aliyun
        uses: peter-evans/create-pull-request@v6
        with:
          branch: auto/manifests-${{ github.run_id }}
          delete-branch: true
          commit-message: |
            chore(manifests): auto-update bucket manifests

            - AliyunDrive: ${{ steps.check-updates.outputs.old_version }} -> ${{ steps.check-updates.outputs.new_version }}
            - Miniforge: ${{ steps.check-miniforge.outputs.old_version }} -> ${{ steps.check-miniforge.outputs.new_version }}
            - LobeChat: ${{ steps.check-lobechat.outputs.old_version }} -> ${{ steps.check-lobechat.outputs.new_version }}
            - Run: ${{ github.run_id }}
          title: "ü§ñ Auto-update: bucket manifests"
          body: |
            This PR updates one or more manifests automatically.

            - AliyunDrive: ${{ steps.check-updates.outputs.old_version }} -> ${{ steps.check-updates.outputs.new_version }}
            - Miniforge: ${{ steps.check-miniforge.outputs.old_version }} -> ${{ steps.check-miniforge.outputs.new_version }}
            - LobeChat: ${{ steps.check-lobechat.outputs.old_version }} -> ${{ steps.check-lobechat.outputs.new_version }}
            - Updated by workflow run: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          labels: auto-update
          add-paths: |
            bucket/aliyundrive.json
            README.md
            bucket/miniforge.json
            bucket/lobechat.json

      # Align with official buckets: do not create issues/releases for auto updates

      # Removed release creation step

  # Êñ∞Â¢ûÔºö‰ΩøÁî®ÂÆòÊñπ Excavator Ëá™Âä®Êõ¥Êñ∞ÂÖ∂‰ªñÂ∫îÁî®
  update-other-apps:
    runs-on: windows-latest
    needs: update-manifests
    concurrency:
      group: update-other-apps-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Custom update trafficmonitor
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $repo = 'zhongyang219/TrafficMonitor'
          $api = "https://api.github.com/repos/$repo/releases/latest"
          $headers = @{ 'User-Agent' = 'gh-actions'; 'Accept' = 'application/vnd.github+json' }
          $resp = Invoke-RestMethod -Uri $api -Headers $headers -UseBasicParsing
          if (-not $resp.tag_name) { throw 'Failed to fetch latest release' }
          $tag = [string]$resp.tag_name  # e.g. V1.85.1
          $version = $tag.TrimStart('V','v')

          Write-Host "Latest tag: $tag; version: $version"

          $assets = @{}
          foreach ($asset in $resp.assets) {
            $assets[$asset.name] = $asset.browser_download_url
          }

          $map = @{
            'x64'   = "TrafficMonitor_V$version`_x64.zip"
            'x86'   = "TrafficMonitor_V$version`_x86.zip"
            'arm64' = "TrafficMonitor_V$version`_arm64ec.zip"
          }

          $tmp = New-Item -ItemType Directory -Path (Join-Path $env:TEMP "tm_$version") -Force
          $hashes = @{}
          foreach ($arch in $map.Keys) {
            $name = $map[$arch]
            if (-not $assets.ContainsKey($name)) { throw "Missing asset $name in latest release" }
            $url = $assets[$name]
            $out = Join-Path $tmp.FullName $name
            Write-Host "Downloading $name ..."
            Invoke-WebRequest -UseBasicParsing -Uri $url -OutFile $out
            $sha = (Get-FileHash -Algorithm SHA256 $out).Hash.ToUpper()
            $hashes[$arch] = @{ url = $url; sha = $sha }
          }

          $manifestPath = 'bucket/trafficmonitor.json'
          $json = Get-Content $manifestPath -Raw | ConvertFrom-Json
          $json.version = $version
          $json.architecture.'64bit'.url  = $hashes['x64'].url
          $json.architecture.'64bit'.hash = $hashes['x64'].sha
          $json.architecture.'32bit'.url  = $hashes['x86'].url
          $json.architecture.'32bit'.hash = $hashes['x86'].sha
          $json.architecture.arm64.url    = $hashes['arm64'].url
          $json.architecture.arm64.hash   = $hashes['arm64'].sha

          # Prepare new JSON content and write only when content actually changes
          $original = Get-Content $manifestPath -Raw
          $newContent = ($json | ConvertTo-Json -Depth 32)
          if ($newContent -ne $original) {
            $newContent | Set-Content -Path $manifestPath -Encoding utf8NoBOM
            Write-Host "Updated $manifestPath to $version"
          } else {
            Write-Host "No real changes in $manifestPath; skip writing"
          }

      - name: Check for changes
        id: check-changes
        shell: pwsh
        run: |
          if (git diff --quiet) {
            "no-changes=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "‚úÖ No changes detected"
          } else {
            "no-changes=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            Write-Host "üìù Changes detected"
            git diff --name-only
          }

      - name: Create Pull Request for Traffic Monitor update
        if: steps.check-changes.outputs.no-changes == 'false'
        id: cpr_tm
        uses: peter-evans/create-pull-request@v6
        with:
          branch: auto/trafficmonitor-${{ steps.check-changes.id }}-${{ github.run_id }}
          delete-branch: true
          commit-message: |
            chore(trafficmonitor): auto-update manifest to latest GitHub release
          title: "ü§ñ Auto-update: Traffic Monitor"
          body: |
            This PR updates Traffic Monitor manifest to the latest GitHub release detected on the Windows runner.

            Workflow Run: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          labels: auto-update, trafficmonitor
          add-paths: |
            bucket/trafficmonitor.json

      # Removed issue creation for Traffic Monitor

      - name: Enable auto-merge for Traffic Monitor PR
        if: steps.cpr_tm.outputs.pull-request-number != ''
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          pull-request-number: ${{ steps.cpr_tm.outputs.pull-request-number }}
          merge-method: squash

      - name: Fallback merge Traffic Monitor PR (if auto-merge not available)
        if: steps.cpr_tm.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr merge ${{ steps.cpr_tm.outputs.pull-request-number }} --auto --squash --delete-branch || \
          gh pr merge ${{ steps.cpr_tm.outputs.pull-request-number }} --squash --delete-branch || true
