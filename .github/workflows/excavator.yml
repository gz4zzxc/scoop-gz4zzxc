name: Auto Update Manifests

on:
  schedule:
    # Run at 8:00 AM Beijing Time (UTC+8) = 00:00 UTC every day
    - cron: '0 0 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  update-manifests:
    runs-on: ubuntu-latest
    concurrency:
      group: update-manifests-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install requests beautifulsoup4 lxml

      - name: Validate current manifests
        run: |
          echo "Validating manifest files..."
          for manifest in bucket/*.json; do
            echo "Checking $manifest..."
            python3 -m json.tool "$manifest" > /dev/null && echo "✅ $manifest is valid JSON" || echo "❌ $manifest has invalid JSON"
          done

      - name: Check for AliyunDrive updates
        id: check-updates
        run: |
          python3 << 'EOF'
          import json
          import re
          import requests
          from datetime import datetime
          import os

          def check_aliyundrive_update():
              try:
                  # Read current version from manifest
                  with open('bucket/aliyundrive.json', 'r', encoding='utf-8') as f:
                      manifest = json.load(f)
                  current_version = manifest['version']

                  print(f"Current version: {current_version}")

                  # Method 1: Try to fetch download page directly
                  try:
                      response = requests.get('https://www.aliyundrive.com/download',
                                            timeout=30,
                                            headers={
                                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                                            })
                      response.raise_for_status()

                      # Extract version from download URL
                      version_match = re.search(r'aDrive-(\d+\.\d+\.\d+)\.exe', response.text)
                      if version_match:
                          latest_version = version_match.group(1)
                          print(f"Found version from download page: {latest_version}")
                      else:
                          raise Exception("Version not found in download page")

                  except Exception as e:
                      print(f"Method 1 failed: {e}")
                      # Method 2: Check if current version download URL is still valid
                      current_download_url = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-{current_version}.exe"
                      print(f"Checking if current version download URL is still valid: {current_download_url}")
                      try:
                          head_response = requests.head(current_download_url, timeout=10, headers={
                              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                          })
                          if head_response.status_code == 200:
                              print("✅ Current version download URL is still valid, assuming no update")
                              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                                  f.write(f"updated=false\n")
                              return False
                          else:
                              print(f"❌ Current download URL returned {head_response.status_code}")
                      except Exception as url_check_error:
                          print(f"❌ Error checking current download URL: {url_check_error}")

                      # Method 3: Try common version increments
                      version_parts = current_version.split('.')
                      if len(version_parts) == 3:
                          # Try incrementing patch version
                          patch = int(version_parts[2])
                          for i in range(1, 10):  # Try next 9 patch versions
                              test_version = f"{version_parts[0]}.{version_parts[1]}.{patch + i}"
                              test_url = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-{test_version}.exe"
                              print(f"Testing version {test_version}...")
                              test_response = requests.head(test_url, timeout=5, headers={
                                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                              })
                              if test_response.status_code == 200:
                                  latest_version = test_version
                                  print(f"Found newer version: {latest_version}")
                                  break
                          else:
                              print("No newer version found through URL testing")
                              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                                  f.write(f"updated=false\n")
                              return False
                      else:
                          print("Cannot parse current version format")
                          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                              f.write(f"updated=false\n")
                          return False

                  download_url = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-{latest_version}.exe"
                  print(f"Latest version: {latest_version}")

                  if latest_version != current_version:
                      # Verify the new URL exists with proper User-Agent
                      verify_response = requests.head(download_url, timeout=10, headers={
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                      })
                      if verify_response.status_code != 200:
                          print(f"❌ New version URL not accessible: {verify_response.status_code}")
                          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                              f.write(f"updated=false\n")
                          return False

                      # Update manifest - keep the placeholder URL structure but update version
                      manifest['version'] = latest_version
                      # Keep the placeholder URL structure unchanged - it uses placeholder.txt
                      # The pre_install script already uses $version variable, so it will automatically use the new version

                      # Update autoupdate URL
                      if 'autoupdate' in manifest:
                          manifest['autoupdate']['url'] = f"https://cdn.aliyundrive.net/downloads/apps/desktop/aDrive-$version.exe"

                      # Write updated manifest
                      with open('bucket/aliyundrive.json', 'w', encoding='utf-8') as f:
                          json.dump(manifest, f, indent=4, ensure_ascii=False)

                      # Set output for GitHub Actions
                      with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                          f.write(f"updated=true\n")
                          f.write(f"old_version={current_version}\n")
                          f.write(f"new_version={latest_version}\n")

                      print(f"✅ Updated AliyunDrive from {current_version} to {latest_version}")
                      return True
                  else:
                      print("✅ AliyunDrive is up to date")
                      with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                          f.write(f"updated=false\n")
                      return False

              except Exception as e:
                  print(f"❌ Error checking AliyunDrive updates: {e}")
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"updated=false\n")
                  return False

          check_aliyundrive_update()
          EOF

      - name: Check for Miniforge updates
        id: check-miniforge
        run: |
          python3 << 'EOF'
          import json
          import re
          import os
          import requests

          def latest_miniforge():
              api = 'https://api.github.com/repos/conda-forge/miniforge/releases/latest'
              r = requests.get(api, timeout=30, headers={'Accept':'application/vnd.github+json','User-Agent':'gh-actions'})
              r.raise_for_status()
              data = r.json()
              tag = data.get('tag_name')
              assets = data.get('assets', [])
              exe_name = f'Miniforge3-{tag}-Windows-x86_64.exe'
              sha_name = exe_name + '.sha256'
              exe_url = None
              sha_url = None
              for a in assets:
                  if a.get('name') == exe_name:
                      exe_url = a.get('browser_download_url')
                  if a.get('name') == sha_name:
                      sha_url = a.get('browser_download_url')
              if not exe_url or not sha_url:
                  raise RuntimeError('Miniforge Windows x86_64 asset or sha256 not found')
              sha_resp = requests.get(sha_url, timeout=30)
              sha_resp.raise_for_status()
              m = re.search(r'^([0-9a-fA-F]{64})', sha_resp.text)
              if not m:
                  raise RuntimeError('Unable to parse sha256')
              sha = m.group(1).lower()
              return tag, exe_url, sha

          try:
              manifest_path = 'bucket/miniforge.json'
              with open(manifest_path, 'r', encoding='utf-8') as f:
                  manifest = json.load(f)
              current_version = manifest.get('version')

              new_version, exe_url, sha = latest_miniforge()

              desired_url = f'https://github.com/conda-forge/miniforge/releases/download/{new_version}/Miniforge3-{new_version}-Windows-x86_64.exe'
              updated = False

              if manifest.get('version') != new_version:
                  updated = True
                  manifest['version'] = new_version

              arch = manifest.setdefault('architecture', {})
              arch64 = arch.setdefault('64bit', {})
              if arch64.get('url') != desired_url:
                  updated = True
                  arch64['url'] = desired_url
              if arch64.get('hash', '').lower() != sha.lower():
                  updated = True
                  arch64['hash'] = sha
              if 'arm64' in arch:
                  updated = True
                  arch.pop('arm64', None)

              desired_autoupdate = {
                  'architecture': {
                      '64bit': {
                          'url': 'https://github.com/conda-forge/miniforge/releases/download/$version/Miniforge3-$version-Windows-x86_64.exe'
                      }
                  },
                  'hash': {
                      'url': 'https://github.com/conda-forge/miniforge/releases/download/$version/Miniforge3-$version-Windows-x86_64.exe.sha256',
                      'regex': '^([a-fA-F]{64})'
                  }
              }
              if manifest.get('autoupdate') != desired_autoupdate:
                  manifest['autoupdate'] = desired_autoupdate
                  updated = True

              if updated:
                  with open(manifest_path, 'w', encoding='utf-8') as f:
                      json.dump(manifest, f, indent=2, ensure_ascii=False)
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write('updated=true\n')
                      f.write(f'old_version={current_version}\n')
                      f.write(f'new_version={new_version}\n')
                  print(f'Updated Miniforge from {current_version} to {new_version}')
              else:
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write('updated=false\n')
                  print('Miniforge is up to date')
          except Exception as e:
              print(f'Error checking Miniforge: {e}')
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write('updated=false\n')
          EOF

      - name: Check for LobeChat updates
        id: check-lobechat
        run: |
          python3 <<'EOF'
          import json, os, re, requests, hashlib

          MANIFEST = 'bucket/lobechat.json'
          REPO = 'lobehub/lobe-chat'
          api = f'https://api.github.com/repos/{REPO}/releases/latest'
          headers = {'Accept':'application/vnd.github+json','User-Agent':'gh-actions'}
          try:
            if os.path.exists(MANIFEST):
              with open(MANIFEST,'r',encoding='utf-8') as f:
                manifest = json.load(f)
            else:
              manifest = {
                'version':'0.0.0',
                'description':'LobeChat desktop client',
                'homepage':'https://github.com/lobehub/lobe-chat',
                'license':'Apache-2.0'
              }
            current_version = manifest.get('version','0.0.0')
            resp = requests.get(api, timeout=30, headers=headers)
            resp.raise_for_status()
            data = resp.json()
            tag = data.get('tag_name','')
            if not tag:
              raise RuntimeError('No tag_name in latest release response')
            version = tag.lstrip('vV')
            assets = data.get('assets', [])
            # 1) 更宽松匹配：包含版本号且以 -setup.exe 结尾
            pattern = re.compile(rf'^LobeHub-.*-{re.escape(version)}-setup\\.exe$', re.IGNORECASE)
            asset = next((a for a in assets if pattern.match(a.get('name',''))), None)
            url = asset.get('browser_download_url') if asset else None
            # 2) 回退：解析 latest.yml，读取 path 字段
            if not url:
              latest_asset = next((a for a in assets if a.get('name') == 'latest.yml'), None)
              if latest_asset and latest_asset.get('browser_download_url'):
                yml_resp = requests.get(latest_asset['browser_download_url'], timeout=30, headers=headers)
                yml_resp.raise_for_status()
                m = re.search(r'^\s*path:\s*(\S+\.exe)\s*$', yml_resp.text, re.MULTILINE)
                if m:
                  exe_name = m.group(1).strip()
                  # 优先从 assets 里再定位一次完整 URL；若未找到则直接拼接
                  asset = next((a for a in assets if a.get('name') == exe_name), None)
                  if asset:
                    url = asset.get('browser_download_url')
                  else:
                    url = f"https://github.com/{REPO}/releases/download/{tag}/{exe_name}"
            if not url:
              raise RuntimeError('Setup asset not found')
            if not url:
              raise RuntimeError('Asset missing download url')
            dl = requests.get(url, timeout=600, stream=True, headers=headers)
            dl.raise_for_status()
            h = hashlib.sha256(); size=0
            for chunk in dl.iter_content(262144):
              if not chunk: continue
              h.update(chunk); size += len(chunk)
            sha256 = h.hexdigest()
            updated = False
            if manifest.get('version') != version:
              manifest['version'] = version; updated = True
            # 用实际获取到的 exe 名称构造 autoupdate URL
            exe_name = url.rsplit('/', 1)[-1]
            desired_url = f"https://github.com/lobehub/lobe-chat/releases/download/v{version}/{exe_name}"
            if manifest.get('url') != desired_url:
              manifest['url'] = desired_url; updated = True
            if manifest.get('hash','').lower() != sha256.lower():
              manifest['hash'] = sha256; updated = True
            if manifest.get('checkver') != {'github':'lobehub/lobe-chat','regex':'v([\\d.]+)'}:
              manifest['checkver'] = {'github':'lobehub/lobe-chat','regex':'v([\\d.]+)'}; updated = True
            if manifest.get('autoupdate') != {'url':'https://github.com/lobehub/lobe-chat/releases/download/v$version/LobeHub-Beta-$version-setup.exe'}:
              manifest['autoupdate'] = {'url':'https://github.com/lobehub/lobe-chat/releases/download/v$version/LobeHub-Beta-$version-setup.exe'}; updated = True
            if updated:
              with open(MANIFEST,'w',encoding='utf-8') as f: json.dump(manifest,f,indent=2,ensure_ascii=False)
              with open(os.environ['GITHUB_OUTPUT'],'a') as f:
                f.write('updated=true\n'); f.write(f'old_version={current_version}\n'); f.write(f'new_version={version}\n')
              print(f'Updated LobeChat {current_version} -> {version} (~{size/1024/1024:.2f} MB)')
            else:
              with open(os.environ['GITHUB_OUTPUT'],'a') as f: f.write('updated=false\n')
              print('LobeChat is up to date')
          except Exception as e:
            print('Error updating LobeChat:', e)
            with open(os.environ['GITHUB_OUTPUT'],'a') as f: f.write('updated=false\n')
          EOF

      - name: Check for Dida365 updates
        id: check-dida365
        run: |
          python3 << 'EOF'
          import json
          import re
          import requests
          import hashlib
          import os

          def check_dida365_update():
              try:
                  # Read current version from manifest
                  with open('bucket/dida365.json', 'r', encoding='utf-8') as f:
                      manifest = json.load(f)
                  current_version = manifest['version']
                  current_hash = manifest.get('hash', '')

                  print(f"Current Dida365 version: {current_version}")

                  # Method 1: Try to fetch the download page to get latest version
                  try:
                      response = requests.get('https://dida365.com/download/windows', timeout=30, headers={
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                      })
                      response.raise_for_status()
                      
                      # Extract version from download page
                      version_match = re.search(r'dida_win_setup_release_x64_([0-9]+)\.exe', response.text)
                      if version_match:
                          version_number = version_match.group(1)
                          # Convert version number to semantic version format
                          if len(version_number) == 4:  # e.g., 6350 -> 6.3.5.0
                              major = version_number[0]
                              minor = version_number[1]
                              patch = version_number[2]
                              build = version_number[3]
                              latest_version = f"{major}.{minor}.{patch}.{build}"
                          else:
                              latest_version = version_number
                          print(f"Found version from download page: {latest_version}")
                      else:
                          raise Exception("Version not found in download page")

                  except Exception as e:
                      print(f"Method 1 failed: {e}")
                      # Method 2: Check if current version download URL is still valid
                      # Convert semantic version to version number for URL
                      version_parts = current_version.split('.')
                      if len(version_parts) == 4:
                          version_number = ''.join(version_parts)
                      else:
                          version_number = current_version
                      
                      current_download_url = f"https://cdn.dida365.cn/download/win64/dida_win_setup_release_x64_{version_number}.exe"
                      print(f"Checking if current version download URL is still valid: {current_download_url}")
                      try:
                          head_response = requests.head(current_download_url, timeout=10, headers={
                              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                          })
                          if head_response.status_code == 200:
                              print("✅ Current version download URL is still valid")
                              # Try to find a newer version by incrementing the version number
                              current_version_num = int(version_number)
                              latest_version = current_version
                              
                              # Try incrementing version number
                              for i in range(1, 50):  # Try next 50 versions
                                  test_version_num = str(current_version_num + i)
                                  test_url = f"https://cdn.dida365.cn/download/win64/dida_win_setup_release_x64_{test_version_num}.exe"
                                  print(f"Testing version {test_version_num}...")
                                  test_response = requests.head(test_url, timeout=5, headers={
                                      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                                  })
                                  if test_response.status_code == 200:
                                      # Convert back to semantic version
                                      if len(test_version_num) == 4:
                                          major = test_version_num[0]
                                          minor = test_version_num[1]
                                          patch = test_version_num[2]
                                          build = test_version_num[3]
                                          latest_version = f"{major}.{minor}.{patch}.{build}"
                                      else:
                                          latest_version = test_version_num
                                      print(f"Found newer version: {latest_version}")
                                      break
                                  elif test_response.status_code == 404:
                                      # If we get a 404, it's likely we've gone past the latest version
                                      print(f"Version {test_version_num} not found (404), assuming latest version is {latest_version}")
                                      break
                                  # For other status codes, continue checking
                          else:
                              print(f"❌ Current download URL returned {head_response.status_code}")
                              # If current version URL is not valid, we need to find the latest version
                              latest_version = current_version
                      except Exception as url_check_error:
                          print(f"❌ Error checking current download URL: {url_check_error}")
                          latest_version = current_version

                  # Convert latest version to version number for URL construction
                  if '.' in latest_version:
                      version_parts = latest_version.split('.')
                      if len(version_parts) == 4:
                          version_number = ''.join(version_parts)
                      else:
                          version_number = latest_version
                  else:
                      version_number = latest_version

                  # Construct download URL using the CDN pattern
                  download_url = f"https://cdn.dida365.cn/download/win64/dida_win_setup_release_x64_{version_number}.exe"
                  print(f"Download URL: {download_url}")

                  # Check if version has changed
                  if latest_version != current_version:
                      print(f"Version changed: {current_version} -> {latest_version}")
                      
                      # Download the file to calculate hash
                      print("Downloading installer to calculate hash...")
                      response = requests.get(download_url, timeout=600, stream=True, headers={
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                      })
                      response.raise_for_status()

                      # Calculate SHA256 hash
                      sha256_hash = hashlib.sha256()
                      for chunk in response.iter_content(chunk_size=8192):
                          sha256_hash.update(chunk)
                      file_hash = sha256_hash.hexdigest()
                      print(f"Calculated SHA256: {file_hash}")

                      # Update manifest
                      manifest['version'] = latest_version
                      manifest['hash'] = file_hash
                      manifest['url'] = download_url + "#dl.7z"

                      # Update autoupdate configuration
                      if 'autoupdate' in manifest:
                          manifest['autoupdate']['url'] = download_url + "#dl.7z"

                      # Write updated manifest
                      with open('bucket/dida365.json', 'w', encoding='utf-8') as f:
                          json.dump(manifest, f, indent=4, ensure_ascii=False)

                      # Set output for GitHub Actions
                      with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                          f.write(f"updated=true\n")
                          f.write(f"old_version={current_version}\n")
                          f.write(f"new_version={latest_version}\n")

                      print(f"✅ Updated Dida365 from {current_version} to {latest_version}")
                      return True
                  else:
                      print("✅ Dida365 is up to date")
                      with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                          f.write(f"updated=false\n")
                      return False

              except Exception as e:
                  print(f"❌ Error checking Dida365 updates: {e}")
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"updated=false\n")
                  return False

          check_dida365_update()
          EOF

      - name: Update README if version changed
        if: steps.check-updates.outputs.updated == 'true' || steps.check-miniforge.outputs.updated == 'true' || steps.check-lobechat.outputs.updated == 'true' || steps.check-dida365.outputs.updated == 'true'
        run: |
          python3 << 'EOF'
          import re

          with open('README.md', 'r', encoding='utf-8') as f:
              content = f.read()

          old_ad = "${{ steps.check-updates.outputs.old_version }}" or None
          new_ad = "${{ steps.check-updates.outputs.new_version }}" or None
          if old_ad and new_ad:
              pattern = r'(\| aliyundrive \| .+ \| )' + re.escape(old_ad) + r'( \|)'
              replacement = r'\g<1>' + new_ad + r'\g<2>'
              content = re.sub(pattern, replacement, content)

          old_mf = "${{ steps.check-miniforge.outputs.old_version }}" or None
          new_mf = "${{ steps.check-miniforge.outputs.new_version }}" or None
          if old_mf and new_mf:
              pattern = r'(\| miniforge \| .+ \| )' + re.escape(old_mf) + r'( \|)'
              replacement = r'\g<1>' + new_mf + r'\g<2>'
              content = re.sub(pattern, replacement, content)

          old_lc = "${{ steps.check-lobechat.outputs.old_version }}" or None
          new_lc = "${{ steps.check-lobechat.outputs.new_version }}" or None
          if old_lc and new_lc:
              # 更新已存在行
              pattern = r'(\| lobechat \| .+ \| )' + re.escape(old_lc) + r'( \|)'
              replacement = r'\g<1>' + new_lc + r'\g<2>'
              new_content, n = re.subn(pattern, replacement, content)
              content = new_content
              # 如果不存在 lobechat 行，则插入一行（在表格头之后）
              if n == 0:
                  table_header = r"| App | Description | Version |\n|-----|-------------|---------|"
                  insert_row = f"\n| lobechat | LobeChat 桌面客户端 | {new_lc} |"
                  content = re.sub(table_header, table_header + insert_row, content, count=1)

          old_dd = "${{ steps.check-dida365.outputs.old_version }}" or None
          new_dd = "${{ steps.check-dida365.outputs.new_version }}" or None
          if old_dd and new_dd:
              # 更新已存在行
              pattern = r'(\| dida365 \| .+ \| )' + re.escape(old_dd) + r'( \|)'
              replacement = r'\g<1>' + new_dd + r'\g<2>'
              new_content, n = re.subn(pattern, replacement, content)
              content = new_content
              # 如果不存在 dida365 行，则插入一行（在表格头之后）
              if n == 0:
                  table_header = r"| App | Description | Version |\n|-----|-------------|---------|"
                  insert_row = f"\n| dida365 | 滴答清单是一款高效的待办事项和时间管理应用，支持多平台同步和团队协作 | {new_dd} |"
                  content = re.sub(table_header, table_header + insert_row, content, count=1)

          with open('README.md', 'w', encoding='utf-8') as f:
              f.write(content)
          EOF

      - name: Check for manifest changes
        id: check-changes-manifests
        run: |
          # 使用 git status 更可靠地检测更改，同时结合步骤输出兜底
          CHANGED=$(git status --porcelain -- bucket/*.json README.md || true)
          if [ -n "$CHANGED" ] || [ "${{ steps.check-updates.outputs.updated }}" = "true" ] || [ "${{ steps.check-miniforge.outputs.updated }}" = "true" ] || [ "${{ steps.check-lobechat.outputs.updated }}" = "true" ] || [ "${{ steps.check-dida365.outputs.updated }}" = "true" ]; then
            echo "no-changes=false" >> $GITHUB_OUTPUT
            echo "Detected changes:" && printf "%s\n" "$CHANGED"
          else
            echo "no-changes=true" >> $GITHUB_OUTPUT
            echo "No changes detected"
          fi

      - name: Commit and push changes directly
        if: steps.check-changes-manifests.outputs.no-changes == 'false'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Add all changed files
          git add bucket/*.json README.md
          
          # Create commit message
          COMMIT_MSG="chore(manifests): auto-update bucket manifests"
          
          if [ "${{ steps.check-updates.outputs.updated }}" = "true" ]; then
            COMMIT_MSG="$COMMIT_MSG - AliyunDrive: ${{ steps.check-updates.outputs.old_version }} -> ${{ steps.check-updates.outputs.new_version }}"
          fi
          
          if [ "${{ steps.check-miniforge.outputs.updated }}" = "true" ]; then
            COMMIT_MSG="$COMMIT_MSG - Miniforge: ${{ steps.check-miniforge.outputs.old_version }} -> ${{ steps.check-miniforge.outputs.new_version }}"
          fi
          
          if [ "${{ steps.check-lobechat.outputs.updated }}" = "true" ]; then
            COMMIT_MSG="$COMMIT_MSG - LobeChat: ${{ steps.check-lobechat.outputs.old_version }} -> ${{ steps.check-lobechat.outputs.new_version }}"
          fi
          
          if [ "${{ steps.check-dida365.outputs.updated }}" = "true" ]; then
            COMMIT_MSG="$COMMIT_MSG - Dida365: ${{ steps.check-dida365.outputs.old_version }} -> ${{ steps.check-dida365.outputs.new_version }}"
          fi
          
          COMMIT_MSG="$COMMIT_MSG - Run: ${{ github.run_id }}"
          
          # Commit and push
          git commit -m "$COMMIT_MSG"
          git push origin HEAD:main




