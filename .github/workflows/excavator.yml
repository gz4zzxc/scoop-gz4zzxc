name: Auto Update Manifests

on:
  push:
    branches: [ main ]
  schedule:
    # Run at 8:00 AM Beijing Time (UTC+8) = 00:00 UTC every day
    - cron: '0 0 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  update-manifests:
    runs-on: windows-latest
    concurrency:
      group: update-manifests-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          persist-credentials: true
          show-progress: false

      - name: Validate JSON manifests
        shell: pwsh
        run: |
          Write-Host 'Validating manifest JSON...' -ForegroundColor Cyan
          Get-ChildItem bucket -Filter *.json | ForEach-Object {
            try {
              Get-Content $_.FullName -Raw | ConvertFrom-Json | Out-Null
              Write-Host "✅ $($_.Name) is valid JSON"
            } catch {
              Write-Host "❌ $($_.Name) has invalid JSON: $($_.Exception.Message)" -ForegroundColor Red
              throw
            }
          }

      - name: Install Scoop (for checkver/autoupdate)
        shell: pwsh
        run: |
          Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
          iwr -useb get.scoop.sh | iex
          scoop config aria2-warning-enabled false
          scoop install git

      - name: Run checkver for all manifests
        shell: pwsh
        run: |
          $checkver = "$env:USERPROFILE\scoop\apps\scoop\current\bin\checkver.ps1"
          if (-not (Test-Path $checkver)) {
            Write-Host "Downloading checkver.ps1 as fallback..." -ForegroundColor Yellow
            $checkver = Join-Path $env:RUNNER_TEMP 'checkver.ps1'
            iwr -useb https://raw.githubusercontent.com/ScoopInstaller/Scoop/master/bin/checkver.ps1 -OutFile $checkver
          }
          & pwsh -File $checkver * -u -dir (Resolve-Path .).Path

      - name: Update README version table
        shell: pwsh
        run: |
          $path = 'README.md'
          if (-not (Test-Path $path)) { exit 0 }
          $content = Get-Content $path -Raw -Encoding UTF8
          # Work on a mutable copy
          $script:content = $content
          # Preserve existing newline style (LF vs CRLF)
          $nl = if ($content -match "\r\n") { "`r`n" } else { "`n" }

          function Update-VersionRow([string]$app, [string]$version) {
            $escaped = [regex]::Escape($app)
            # Capture the whole row, splitting into: pre (up to version cell), ver (the version cell), post (closing pipe)
            $pattern = "(?m)^(?<pre>\|\s*$escaped\s*\|.*?\|\s*)(?<ver>[^|\r\n]+?)(?<post>\s*\|)$"
            $updated = $false
            $script:content = [regex]::Replace($script:content, $pattern, {
              $updated = $true
              return $args[0].Groups['pre'].Value + $version + $args[0].Groups['post'].Value
            }, 1)
            # replacement done when $updated is true

            if (-not $updated) {
              # If the row does not exist, insert a new row after the header row
              $insert = "| $app | (auto) | $version |$nl"
              $tableHeader = "(?ms)(\|\s*App\s*\|.*?\|\s*Version\s*\|\s*\r?\n\|[-| ]+\r?\n)"
              if ([regex]::IsMatch($script:content, $tableHeader)) {
                $script:content = [regex]::Replace($script:content, $tableHeader, {
                  $args[0].Groups[1].Value + $insert
                }, 1)
              } else {
                # Fallback: append at end
                if (-not $script:content.EndsWith("`n")) { $script:content += $nl }
                $script:content += $insert
              }
            }
          }

          $apps = @(
            @{ key = 'aliyundrive'; file = 'bucket/aliyundrive.json' },
            @{ key = 'miniforge';  file = 'bucket/miniforge.json'  },
            @{ key = 'lobehub';    file = 'bucket/lobehub.json'    },
            @{ key = 'eudic';      file = 'bucket/eudic.json'      },
            @{ key = 'dida365';    file = 'bucket/dida365.json'    }
          )

          foreach ($a in $apps) {
            if (Test-Path $a.file) {
              try {
                $ver = (Get-Content $a.file -Raw | ConvertFrom-Json).version
                if ($ver) { Update-VersionRow -app $a.key -version $ver }
              } catch {
                Write-Host "Skip $($a.key): failed to read version" -ForegroundColor Yellow
              }
            }
          }

          if ($content -ne $script:content) {
            Set-Content -Path $path -Value $script:content -Encoding UTF8
            Write-Host 'README updated with latest versions.' -ForegroundColor Green
          } else {
            Write-Host 'README already up to date.'
          }

      - name: Show changes
        id: diff
        shell: pwsh
        run: |
          $changed = git status --porcelain -- bucket/*.json README.md
          $changed | Write-Host
          if (-not [string]::IsNullOrWhiteSpace($changed)) { echo "changed=true" >> $env:GITHUB_OUTPUT } else { echo "changed=false" >> $env:GITHUB_OUTPUT }

      - name: Commit changes
        if: steps.diff.outputs.changed == 'true'
        shell: pwsh
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add bucket/*.json README.md

          $manifestFiles = git diff --cached --name-only -- 'bucket/*.json'
          $manifestInfo = @()

          foreach ($file in $manifestFiles) {
            if (-not (Test-Path $file)) { continue }
            try {
              $json = Get-Content $file -Raw | ConvertFrom-Json
              $app = [IO.Path]::GetFileNameWithoutExtension($file)
              $version = $json.version
              if ($app -and $version) {
                $manifestInfo += [pscustomobject]@{ App = $app; Version = $version }
              }
            } catch {
              Write-Host "Skip commit summary for ${file}: $($_)" -ForegroundColor Yellow
            }
          }

          if ($manifestInfo.Count -eq 1) {
            $subject = "chore(bucket): bump $($manifestInfo[0].App) to $($manifestInfo[0].Version) [skip ci]"
          } elseif ($manifestInfo.Count -gt 1) {
            $preview = if ($manifestInfo.Count -le 3) { $manifestInfo } else { $manifestInfo[0..2] + '...' }
            $summary = $preview | ForEach-Object { if ($_ -is [string]) { $_ } else { "$($_.App) $($_.Version)" } }
            $subject = "chore(bucket): bump manifests ($($summary -join ', ')) [skip ci]"
          } elseif (git diff --cached --name-only -- 'README.md') {
            $subject = "docs: refresh README version table [skip ci]"
          } else {
            $subject = "chore: sync auto-generated files [skip ci]"
          }

          git commit -m $subject
          git push origin HEAD:main
